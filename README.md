# Algorithm with Python
파이썬을 이용한 알고리즘 공부 Repository입니다.
## [basic](https://github.com/jiyoung0340/algorithmWithPython/blob/main/concept/basic.py)
파이썬의 기본 문법
## [greedy](https://github.com/jiyoung0340/algorithmWithPython/blob/main/concept/greedy.py)
그리디 알고리즘 : 현재 상황에서 지금 당장 좋은 것만 고르는 방법


**Q1. 거스름 돈 문제**

    가장 큰 화폐 단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유?  
    가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.  
    따라서 그리디 알고리즘 문제에서는 문제풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 줄 알아야한다.  


**Q2. 1이 될 때까지**  
N이 1이 될 때까지 다음의 과정중 하나를 반복적으로 선택해 수행한다. 단, 두번째 연산은 N이 k로 나누어 떨어질 때만 선택할 수 있다.
- N에서 1을 뺀다.
- N을 k로 나눈다.

예를 들어 N이 17, k가 4일때, 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다.  
따라서 전체 과정을 실행한 횟수는 3이 된다.

**Q3. 곱하기 혹은 더하기**  
각 자리가 숫자로만 이루어진 문자열 S. 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x'혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성해라.
단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다.

**Q4. 모험가 길드**  
한 마을의 모험가 N명을 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 위기 상황에서 대처할 능력이 떨어진다.  이에 길드장은 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있다.  
최대 몇개의 모험가 그룹을 만들 수 있는가?

## [completeSearch (완전탐색)](https://github.com/jiyoung0340/algorithmWithPython/blob/main/concept/completeSearch.py)
2차원 공간에서의 방향 벡터가 활용됨
```python  
# 동, 북, 서, 남  
dx = [0, -1, 0, 1]  
dy = [1, 0, -1, 0]  
  
# 현재 위치  
x, y = 2, 2  
  
for i in range(4):  
    # 다음 위치  
    nx = x + dx[i]  
    ny = y + dy[i]  
    print(nx, ny)  
```  
**Q1. 상하좌우**  
A는 N X N 크기의 정사각형 공간 위에 있다. 이 공간은 1X1 크기의 정사각형으로 나누어져 있고, 가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는 (N, N) 이다. A는 상,하,좌,우로 이동할 수 있으며, 시작 좌표는 항상 (1,1)이다. 다음은 A가 이동할 계획이 적힌 계획서가 있다.  
계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여, L, R, U, D중 하나의 문자가 반복적으로 적혀 있고 그 의미는 다음과 같다
- L : 왼쪽으로 한 칸 이동
- R : 오른쪽으로 한 칸 이동
- U : 위로 한 칸 이동
- D : 아래로 한 칸 이동

이때 A가 N X N 크기 정사각형 공간을 벗어나는 움직임은 무시한다.

**Q2. 시간 문제(완전 탐색)**

    이 문제는 가능한 모든 시각의 경우를 모두 세서 풀 수 있는 문제이다.  
    단순히 시각을 1 씩 증가시키면서 3이 하나라도 포함되어 있는지 확인 
정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오.

**Q3. 왕실의 나이트**  
체스판 8X8 좌표 평면위에 나이트가 서있다. 나이트는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 나이트는 다음 2가지 경우로 이동할 수 있다.
1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기
2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기

나이트가 이동할 수 있는 경우의 수를 출력하시오.(행 위치는 1-8, 열 위치는 a-h로 표현한다.)

**Q4. 문자열 재정렬**  
알파벳 대문자와 숫자로만 구성된 문자열을 입력한다. 이때 모든 알파벳을 오름차순으로 정렬하여 출력한 뒤에 모든 숫자를 더한 값을 이어서 출력한다.

******
> **스택**

먼저 들어온 데이터가 나중에 나가는 형식 - **선입후출**  
파이썬에서는 별도의 라이브러리 사용없이 list의 append(), pop()함수를 사용해 스택을 활용할 수 있다.
```python  
# stack  
stack = []  
stack.append(5)  
stack.append(2)  
stack.append(3)  
stack.append(7)  
stack.pop()  
stack.append(1)  
stack.append(4)  
stack.pop()  
  
# 최상단 원소부터 출력  
print(stack[::-1])  
# 최하단 원소부터 출력  
print(stack)  
```  
>**큐**

먼저 들어온 데이터가 먼저 나가는 형식 - **선입선출**  
deque 라이브러리 사용 -> list로 기능적으로 사용가능하나 시간복잡도가 더 높음  
*단, deque의 경우는 오른쪽으로 데이터가 들어와 왼쪽으로 나간다고 생각해야함!*
```python  
# Queue  
from collections import deque  
# Queue구현을 위해 deque 라이브러리 사용  
queue = deque()  
queue.append(5)  
queue.append(2)  
queue.append(3)  
queue.append(7)  
queue.popleft()  
queue.append(1)  
queue.append(4)  
queue.popleft()  
  
# 들어온 순서대로 출력  
print(queue)  
# 역순으로 출력  
queue.reverse()  
print(queue)   
```  
>**재귀함수**

자기 자신을 다시 호출하는 함수 -> 무한히 출력할 경우 최대 재귀 깊이 초과 메시지 출력됨. 따라서 종료조건을 명시해야함
```python  
# 팩토리얼 구현  
# n! = 1 * 2 * 3 * 4 * ... * (n - 1) * n  
# 0!, 1! = 1  
  
# 반복적으로 구현한 n!  
def factorial_interative(n):  
    result = 1  
    # 1부터 n까지 차례대로 곱하기  
  for i in range(1, n+1):  
        result *= i  
    return result  
  
# 재귀적으로 구현한 n!  
def factorial_recursive(n):  
    if n <= 1: # n이 1이하인 경우 1 반환  
  return 1  
    # n! = n * (n-1)! 를 그대로 코드로 작성  
  return n * factorial_recursive(n - 1)  
  
print('반복 : ', factorial_interative(5))  
print('재귀 : ', factorial_recursive(5))  
  
# 최대공약수 계산 - 유클리드 호제법  
# 유클리드 호제법이란?  
# 두 자연수 A, B에 대하여 (A > B) A를 B로 나눈 나머지를 R이라고 한다.  
# 이때 A, B의 최대공약수는 B와 R의 최대공약수와 같다.  
def gcd(a, b):  
    if a % b == 0:  
        return b  
  else:  
        return gcd(b, a % b)  
  
print(gcd(192, 162))  
```  
****
## [DFS](https://github.com/jiyoung0340/algorithmWithPython/blob/main/concept/dfs.py), [BFS](https://github.com/jiyoung0340/algorithmWithPython/blob/main/concept/bfs.py)
탐색? 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
>### DFS (깊이 우선 탐색)

스택 자료구조(혹은 재귀 함수)를 이용.
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복

**Q. 음료수 얼려먹기**  
N(세로길이) * M(가로길이) 크기의 얼음틀이 있다. 구멍이 뚫린 부분은 0, 칸막이가 존재하는 부분은 1로 표시. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주.  
이때 얼음 틀의 모양이 주어졌을 때 생성되는 아이스크림의 수는?  
00110  
00011  
11111  
00000  
의 경우에는 총 3개의 아이스크림이 생성됨  
*'연결된 얼음을 인접 노드라고 생각한다. 시작노드부터 연결된 모든 노드를 방문하고, 1인 경우에는 이동하지 못하기 때문에 방문한 것으로 간주. '*
1. 특정 지점의 상,하,좌,우를 살펴본 후, 주변 지점 중에서 값이 '0'이면서 아직 방문하지 않은 지점이 있으면 해당 지점 방문
2. 방문한 지점에서 다시 상,하,좌,우를 살펴보면서 방문을 진행하는 과정을 반복하면, 연결된 모든 지점을 방문
3. 모든 노드에 대해 1,2번을 반복, 방문하지 않은 지점의 수를 카운트

>### BFS (너비 우선 탐색)

가까운 노드부터 우선적으로 탐색하며, 큐 자료구조를 이용  
다리 선의 비용이 모두 같다는 가정하에 최단거리 문제에서도 사용됨.
1. 탐색 시작 노드를 큐에 삽입하고 방문처리
2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 모든 노드를 큐에 삽입하고 방문 처리
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복


**Q. 미로탈출**  
N * M 크기의 미로가 있다. A의 위치는 (1, 1)이며 미로의 출구는 (N, M)이고, 한 번에 한 칸씩 이동할 수 있다.  
이때 갈 수 없는 부분은 0으로, 갈 수 있는 부분은 1로 표시한다. 탈출하기 위한 최소 칸의 개수는?  
단, 칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함해서 계산한다.  
101010  
111111  
000001  
111111  
111111   
인 경우 정답은 10이다.

***'BFS는 연결 값이 동일한 경우 최단 거리를 찾는데 좋은 방법이다. 시작지점에서 가까운 노드부터 차례대로 그래프의 모든 노드를 탐색한다.'***
1. (1, 1)의 위치에서 시작
2. (1, 1)좌표에서 상,하,좌,우로 탐색을 진행하면 바로 옆 노드인 (1, 2) 위치의 노드를 방문하게 되고 새롭게 방문하는 (1, 2) 노드의 값을 2로 바꾼다.
3. BFS를 계속 수행하면 결과적으로 다음과 같이 최단 경로의 값들이 1씩 증가하는 형태로 변경

## [정렬(Sort)](https://github.com/jiyoung0340/algorithmWithPython/blob/main/concept/sorting.py)
정렬? 데이터를 특정한 기준에 따라 순서대로 나열하는 것  
*일반적으로 문제 상황에 따라 적절한 정렬 알고리즘이 공식처럼 사용됨*  
대부분의 프로그래밍 언어에서 지원하는 표준 정렬 라이브러리는 최악의 경우에도 O(NlogN)을 보장하도록 설계되어있음.

> **선택정렬 O(n^2)**

가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복.  
탐색을 진행할수록 탐색 범위는 줄어듦.  

```python
arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(arr)):  # i: 가장 작은 데이터와 위치가 바뀐 인덱스를 의미 = 매번 앞쪽으로 보내고자하는 곳에 위치한 인덱스
    min_index = i  # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(arr)):
        if arr[min_index] > arr[j]:
            min_index = j
    # for문이 완료되면 min_index는 탐색범위 내에서 가장 작은 원소를 가르키고 있음.
    arr[i], arr[min_index] = arr[min_index], arr[i]  # 스와프
print(arr)
```

> **삽입정렬 O(n^2)**

처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입  
구현 난이도는 높으나 효율적임! 최선의 경우(=현재 리스트가 거의 정렬되어 있는 상태) O(n)의 시간 복잡도를 가진다.
```python
arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(arr)):
    for j in range(i, 0, -1):  # 인덱스 i부터 1까지 1씩 감소하며 반복
        # j : 삽입하고자 하는 원소의 위치
        if arr[j] < arr[j - 1]:  # 한 칸씩 왼쪽으로 이동
            arr[j], arr[j - 1] = arr[j - 1], arr[j]
        else:  # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break
print(arr)
```
> **퀵 정렬**

기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법  
1. 첫 번째 데이터를 기준 데이터(Pivot)으로 설정한다.
2. 피벗을 기준으로 왼쪽부터 큰 데이터를, 오른쪽부터 작은 데이터를 고른다.
3. 각 방향의 데이터를 바꿔준다.
4. 위치가 엇갈리는 경우 '피벗'과 '작은데이터'의 위치를 서로 변경한다.
5. 이때 피벗을 기준으로 왼쪽은 모두 작은 데이터, 오른쪽은 모두 큰 데이터가 있다.  
이렇게 피벗을 기준으로 데이터 묶음을 나누는 작업을 **분할**이라고 한다.
6. 왼쪽과 오른쪽을 각각 하나의 배열로 보고 다시 퀵 정렬을 수행한다.  

평균의 경우 O(NlogN), 최악의 경우 O(n^2) (최악의 경우 => 이미 정렬된 배열)
```python
arr = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end:  # 원소가 1개인 경우 종료
        return
    pivot = start  # 첫번째 원소가 피벗
    left = start + 1
    right = end
    while left <= right:
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while left <= end and array[left] <= array[pivot]:
            left += 1
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while right > start and array[right] >= array[pivot]:
            right -= 1
        if left > right:  # 엇갈렸다면 작은 데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[right]
        else:  # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            array[left], array[right] = array[right], array[left]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

print(quick_sort(arr, 0, len(arr) - 1))


# 퀵 정렬 2
def quick_sort(array):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(array) <= 1:
        return array
    pivot = array[0] # 피벗은 첫 번째 원소
    tail = array[1:] # 피벗을 제외한 리스트

    left_side = [x for x in tail if x <= pivot] # 분할된 왼쪽 부분
    right_side = [x for x in tail if x > pivot] # 분할된 오른쪽 부분

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행하고, 전체 리스트 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(arr))
```
> **계수 정렬**

각각 데이터가 몇 번 씩 등장했는지를 세며 정렬하는 방식  
특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게 동작한다.  
데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능  
데이터 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행 시간 O(N+K)를 보장  
*최솟값부터 최댓값까지의 리스트를 할당해야하기 때문에 공간 복잡도는 높은 편*  
예를 들어 데이터가 0과 999,999로 단 두개만 존재하는 경우 심각한 비효율성을 초래한다.  
반대로 동일한 값이 여러개 등장할 경우 효과적임.  
```python
# 모든 원소의 값이 0보다 크거나 같다고 가정
arr =  [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(arr) + 1)

for i in range(len(arr)):
    count[arr[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력

print(arr)
```
**Q.두 배열의 원소 교체**  
두 배열 A와 B가 있다. 두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수이다.  
최대 K번의 바꿔치기 연산을 수행할 수 있는데, 바꿔치기 연산이란 배열 A에 있는 원소 하나와 B에 있는 원소 하나를 골라 두 원소르 서로 바꾸는 것이다.    
최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 프로그램을 작성하라.  
```text
* 매번 배열 A에서 가장 작은 원소를 골라서, 배열 B에서 가장 큰 원소와 교체한다.
A배열은 오름차순, B배열은 내림차순으로 정렬한 후, 첫 번째 인덱스부터 차례로 확인하며 A원소가 B원소보다 작을때에만 교체를 수행한다.
```
## [이진탐색 O(logN)](https://github.com/jiyoung0340/algorithmWithPython/blob/main/concept/binarySearch.py)
순차 탐색 : 리스트 안에 있는 특정하 ㄴ데이터를 찾기 위해 앞에서부터 데이터를 하나씩 확인하는 방법  
이진 탐색 : 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법  
*이진탐색은 시작점, 끝점, 중간점을 이용하여 탐색 범위를 설정한다. 중간점은 시작점, 끝점의 가운데로 소숫점은 제거한다*

```python
# 이진 탐색 소스코드 구현(재귀함수)
def binary_search1(array, target, start, end):
    if start > end:
        return None
    mid = (start + end) // 2
    # 찾은 경우 중간점 인덱스 반환
    if array[mid] == target:
        return mid
    # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
    elif array[mid] > target:
        return binary_search1(array, target, start, mid - 1)
    # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
    else:
        return binary_search1(array, target, mid + 1, end)

# 이진 탐색 소스코드 구현(반복문)
def binary_search2(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        # 찾은 경우 중간점 인덱스 반환
        if array[mid] == target:
            return mid
        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        elif array[mid] > target:
            end = mid - 1
        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else:
            start = mid + 1
    return None

# n(원소의 개수)과  target(찾고자 하는 값)을 입력 받기
n, target = map(int, input().split())
# 전체 원소 입력 받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search1(array, target, 0, n-1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
```
> **파라메트릭 서치(Parametric Search)**

최적화 문제를 결정 문제(Yes or No)로 바꾸어 해결하는 기법.  
ex. 특정한 조건을 만족하는 가장 알맞은 값을 빠르게 찾는 최적화 문제    

**Q. 떡볶이 떡 만들기**  
길이가 일정하지 않은 떡들이 있다. 절단기는 높이(H)를 지정하면 줄지어진 떡을 한 번에 절단하여 길이가 H보다 긴 떡은 잘리고, 낮은 떡은 잘리지 않는다.  
예를 들어 높이가 19, 14, 10, 17cm인 떡이 있고 절단기의 높이를 15cm로 지정하면 자른 뒤 떡의 높이는 15, 14, 10, 15cm가 되고  
잘린 떡의 길이는 4, 0, 0, 2cm가 되어 손님은 총 6cm만큼 길이를 가져간다.  
손님이 왔을 때 요청한 길이가 M일 때 적어도 M만큼의 떡을 얻기 위해 절단기에 설정할 수 있는 높이의 최댓값은?
```text
- 적절한 높이를 찾을 때까지 이진 탐색을 수행해 H를 조정한다
  ㄴ 절단기 높이(H)가 클수록 잘린 떡의 길이는 작아질 것이고, H가 작을 수록 떡의 길이는 커지므로 이진 탐색을 통해 조절한다.
- '현재 이 높이로 자르면 조건을 만족할 수 있는가?'를 확인한 뒤에 조건의 만족 여부(Yes Or No)에 따라서 탐색 범위를 좁혀서 해결한다.
- 절단기의 높이는 0부터 10억까지의 정수 => 큰 탐색 범위의 경우 가장 먼저 이진탐색을 떠올린다

중간점의 값은 시간이 지날수록 '최적화된 값'이 되기 때문에, 과정을 반복하면서 얻을 수 있는 떡의 길이 합이 
필요한 떡의 길이보다 크거나 같을 때마다 중간점의 값을 기록한다.
```
**Q. 정렬된 배열에서 특정 수의 개수 구하기**
N개의 원소를 포함하는 수열이 오름차순으로 정렬되어 있다. 이때 이 수열에서 x가 등장하는 횟수를 계산해라.  
예를 들어 수열 (1, 1, 2, 2, 2, 2, 3)이 있을 때, x = 2라면, 현재 수열에서 값이 2인 원소가 4개 이므로 4를 출력한다.  
*단 이 문제의 시간 복잡도는 O(logN)을 넘지 않도록 한다.*

## 다이나믹 프로그래밍 (동적 계획법)  
메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법  
이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.  
 - 탑다운 / 바텀업 방식이 있음.  
  
 다음의 조건을 만족할 때 사용 가능함.
1. 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있고, 작은 문제의 답을 모아 큰 문제를 해결할 수 있다.
2. 중복되는 부분 문제 : 동일한 작은 문제를 반복적으로 해결한다.

**EX.피보나치 수열**  
1, 1, 2, 3, 5, 8, 13, 21, 34, 55... 로 앞 두 숫자의 합이 다음 숫자가 되는 것을 피보나치 수열이라 한다.  
*점화식? 인접한 항들 사이의 관계식*  
피보나치 수열의 점화식 : An = An-1 + An-2, A1 = 1, A2 = 1  
재귀 함수를 사용해 구현 할 경우의 시간 복잡도 = O(2^n) **중복되는 계산이 존재함**  

> **하향식(탑다운)방식**

메모이제이션? 한번 계산한 결과를 메모리 공간에 메모하는 기법(캐싱)  
작은 문제들을 재귀함수에 사용해 큰 문제를 해결한다.  
시간복잡도 = O(n)
> **상향식(바텀업)방식**

아래부터 작은 문제들을 해결해가면서 다음 문제를 해결함 (반복문 사용)  
결과 저장용 리스트를 *DP테이블* 이라고 함

> **다이나믹 프로그래밍 VS 분할 정복(ex. 퀵정렬)**

공통점 : 최적 부분 구조를 가질 때 사용 가능하다.  
차이점 : 부분 문제의 중복  
- 다이나믹 프로그래밍 : 각 부분문제들이 서로 영향을 미치며 부분 문제가 중복됨
- 분할 정복 : 동일한 부분 문제가 반복적으로 계산되지 않음

```text
* 다이나믹 프로그래밍 문제에 접근하는 방법 *
1. 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요!
2. 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토
    > 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려해본다.
3. 일단 재귀 함수로 비효율적인 완전 탐색 프로그램(탑다운)을 작성한 뒤에 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면,
    코드를 개선하는 방법을 사용한다.
4. 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많다.
```
**Q. 개미전사**  
개미는 부족한 식량을 충당하고자 메뚜기의 식량창고를 공격하려고한다. 메뚜기의 여러 식량 창고는 일직선으로 이어져 있고, 각 식량창고에는 정해진 수의 식량을 저장하고 있다.  
개미는 식량창고를 선택적으로 약탈하되, 메뚜기는 일직선상에 존재하는 식량창고 중 서로 인접한 식량창고가 공격받으면 알아챌 수 있다.
따라서 개미는 식량창고를 약탈할 때 최소한 한 칸 이상 떨어진 식량창고를 약탈해야한다.  

예를 들어, 식량창고 4개가 {1, 3, 1, 5}로 있다고 한다. 이때 개미는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값이 8의 식량을 빼앗을 수 있다.
식량창고 N개의 정보가 주어졌을 때, 억을 수 있는 식량의 최댓값을 구하라.
```text
i번째의 식량창고를 털지 안털지 여부를 결정하기 위해 고려될 상황은 두가지이다.
1. i-1번까지 털었을 경우
2. i-2번까지 털었을 경우
이때 1번의 상황과 2번의 상황 + i번째의 식량창고 값을 비교해 더 큰 상황으로 결정한다.

An = n번째 식량창고까지의 최적의 해
Kn = n번째 식량창고에 있는 식량의 양 일때 점화식은 다음과 같다
        An = max(An-1, An-2 + Kn)
한 칸 이상 떨어진 식량창고는 항상 털 수 있으므로 n-3번째 이하는 고려할 필요없음.
```

**Q. 1로 만들기**  
정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 다음과 같다.
1. X가 5로 나누어 떨어지면, 5로 나눈다.
2. X가 3으로 나누어 떨어지면, 3으로 나눈다.
3. X가 2로 나누어 떨어지면, 2로 나눈다.
4. X에서 1을 뺀다.  

X에 대해 위 4개 연산을 적절히 활용해 1로 만들고자 한다. 연산을 사용하는 횟수의 최솟값을 구하라.  
예를 들어 X가 26이면 다음과 같이 계산해 최솟값은 3이 된다.  
- 26 -> 25 -> 5 -> 1
```text
An = n을 1로 만들기 위한 최소 연산 횟수로 점화식은 다음과 같다
        An = min(An-1, An/2, An/3, An/5) + 1
단, 1을 빼는 연산을 제외하고는 해당 수로 나누어 떨어질 때에 한해 점화식을 적용할 수 있다.
``` 

**Q. 효율적인 화폐 구성**  
N가지 종류의 화폐가 있다. 화폐의 개수를 최소한으로 사용해 그 가치의 합이 M이 되도록 해라.  
예를 들어 2, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.  
```text
An = n을 만들 수 있는 최소한의 화폐개수
m = 각 화폐의 단위
각 화폐 단위인 m을 하나씩 확인하며 점화식은 다음과 같다.
- An-m을 만드는 방법이 존재하는 경우, An = min(An, An-m + 1)
- An-m을 만드는 방법이 존재하지 않는 경우, An - INF
```
1. 각 인덱스에 해당하는 값으로 INF(무한)의 값으로 설정한다. : 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미.
2. 첫 번째 화폐단위를 확인하고 점화식에 따라 리스트를 갱신한다.
3. 두 번째 화폐단위를 확인하고 점화식에 따라 리스트를 갱신한다.
4. ... n 번째 화폐단위를 확인하고 점화식에 따라 리스트가 최종 갱신된다.

## 최단경로 알고리즘

가장 짧은 경로를 찾는 알고리즘
- 한 지점에서 다른 한 지점까지의 최단 경로
- 한 지점에서 다른 모든 지점까지의 최단 경로
- 모든 지점에서 다른 모든 지점까지의 최단 경로

각 지점은 그래프에서 **노드**로, 지점 간 연결된 도로는 **간선**으로 표현  

> **다익스트라 최단 경로 알고리즘 : O(n^2)**  
  
특정한 노드에서 출발해 다른 모든 노드로 가는 최단경로를 계산  
음의 간선이 없을 경우 정상 작동 *(현실 세계의 도로는 음의 간선으로 표현되지 않음)*  
그리디 알고리즘으로 분류됨 -> 매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택해 반복  
단계를 거치며 한 번 처리된 노드의 최단 거리는 고정되어 있다.  
테이블에는 각 노드까지의 최단 거리 정보가 저장(완벽한 형태의 최단 경로를 구하기 위해서는 소스코드를 추가해야함)  
일반적으로 노드의 개수가 5000개 이하일 때, 다익스트라 알고리즘으로 풀이 가능
```text
* 일반적으로 최단 경로 알고리즘은 다이나믹 알고리즘으로 분류된다.
ex. A -> (B) -> C 의 경로는
A -> B 의 최단경로에 B -> C의 최단경로를 합친 것이기 때문!
```
**동작과정**  
1. 출발 노드 설정 
2. 최단 거리 테이블 초기화 (출발~그 외 노드 : 무한 / 출발~출발 : 0 으로 초기화)
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택 ->  *그리디알고리즘*
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
5. 3, 4번을 반복  

알고리즘 동작 과정에서 최단 거리 테이블은 각 노드에 대한 현재까지의 최단 거리 정보를 가지고 있다.  
처리 과정에서 더 짧은 경로를 찾으면 해당 경로를 가장 짧은 경로로 갱신한다.  
 
### 우선순위 큐

우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조  
여러 개의 데이터를 자료구조에 넣었다가 가치가 높은 데이터부터 꺼내 확인하는 경우 사용  
* **힙**  
우선순위 큐를 구현하기 위해 사용하는 자료구조로 최소 힙(Min Heap), 최대 힙(Max Heap)이 있음.
    - 최소힙 : 값이 낮은 데이터부터 꺼내는 방식
    - 최대힙 : 값이 높은 데이터부터 꺼내는 방식
```text 
리스트 : 삽입 시간 O(1)    삭제 시간 O(N)
힙    : 삽입 시간 O(logN) 삭제 시간 O(logN)

리스트의 경우 삽입은 맨 뒤에 삽입해서 O(1)이지만, 삭제할 때에는 순회해서 가장 높은 데이터를 찾아야하기때문에  O(N)
힙은 내부의 트리구조를 사용해 삽입, 삭제 모두 O(logN)의 시간이 걸림 
```

### 개선된 다익스트라 알고리즘 : O(ElogV) *E:간선 개수, V:노드 개수*
방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 힙(Heap) 자료구조를 이용한다.  
*동작 기본 원리는 동일*하다. 단, 현재 가장 가까운 노드를 저장해 놓기 위해서 힙 자료구조를 추가적으로 이용한다는 점이 다르다.  
현재 최단 거리가 가장 짧은 노드를 선택해야 하므로 **최소힙**을 사용한다.

> **플로이드 워셜 알고리즘 : O(N^3)**

모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산하는 알고리즘.  
단계별로 거쳐 가는 노드를 기준으로 알고리즘 수행하지만, 다익스트라 알고리즘과 다르게   
*방문하지 않은 노드중 최단거리 노드를 찾는 과정이 필요하지 않음.*  
2차원 테이블을 이용해 최단 거리 정보를 저장. -> 다이나믹 프로그램 유형에 속함.
```text
각 단계마다 특정 노드 K를 거쳐 가는 경우를 확인한다.
            <점화식>
    Dnm = min(Dnm, Dnk + Dkm)   
```
**Q. 전보**  
N개의 도시가 있으며 서로 통로를 향해 메시지를 전송할 수 있다. 예를 들어 X도시에서 Y도시로 향하는 통로가 설치 되어있을 경우,  
X는 Y로 전보를 보낼수 있지만, Y는 X로 전보를 보낼 수 없다. 또한 통로를 거쳐 메시지를 보낼 때에는 일정 시간이 소요 된다.  
이때, C나라에서 최대한 많은 도시로 메시지를 보내고자할 때, 이 메시지를 받는 도시의 개수는 총 몇 개이며,  
모두 메시지를 받는데까지 걸리는 시간을 얼마인가?  
```text
첫째줄에 도시의 개수 N, 통로의 개수 M, 메시지를 보내고자하는 도시 C가 주어진다
두번째 줄부터 M+1번째 줄까지 통로에 대한 정보 X, Y, Z가 주어진다. 이때 X, Y, Z는
도시 X에서 Y로 가는 통로가 있으며 메시지가 전달되는 시간은 Z임을 의미한다.
 
입력 예시           출력 예시
3 2 1               2 4
1 2 4
1 3 2
```
 **Q. 미래 도시**
 1번부터 N번까지의 회사가 있고 서로 도로를 통해 연결되어있다. A는 1번 회사에 위치해 있으며, X번 회사에 방문할 예정이다.  
 이때 연결된 두 회사는 양방향으로 이동 가능하며 정확히 1 만큼의 시간으로 이동 가능하다. 이때 A는 X번 회사에 방문하기 전,  
 K번 회사를 방문할 예정이다. 이때 A가 이동하는 최소 시간을 계산해라.  
 ```text
첫째 줄에 회사 개수 N, 경로의 개수 M이 주어진다
둘재 줄부터 M + 1번째 줄에는 연결된 두 회사의 번호가 공백으로 구분되어 주어진다.
M + 2번째 줄에는 X와 K가 공백으로 구분되어 차례대로 주어진다.

입력 예시       출력 예시
5 7             3
1 2
1 3
1 4 
2 4
3 4
3 5
4 5
4 5
```
=> N의 크기가 최대 100이므로 플로이드 워셜 알고리즘 사용!

## 기타 그래프 이론

> **서로소 집합 자료구조**  

*서로소 집합?* 공통 원소가 없는 두 집합  
서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조  
    - 합집합(Union) : 두 개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산  
    - 찾기(Find) : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산  
=> 서로소 집합 자료구조를 *합치기 찾기(Union Find) 자료구조* 라고도 함.  
기본적인 형태의 서로소 집합 자료구조에서는 루트 노드에 즉시 접근할 수 없음.  
    ㄴ 루트 노드를 찾기 위해 부모 테이블을 계속해서 확인하며 거슬러 올라가야함.  
```text
* 서로소 집합 자료구조의 문제점 *
    - 합집합(Union) 연산이 편향될 경우 찾기(Find)함수가 비효율적으로 동작
    - 최악의 경우 찾기(Find)함수가 모든 노드를 다 확인하게 되어 O(V)이 됨.
    
* 경로 압축(Path Compression)
- 찾기(Find)함수를 최적화 하기위한 방법
- 경로 압축 기법을 사용하면 찾기(Find)함수를 호출한 이후에 해당 노드의 루트 노드가 바로 부모노드가 됨.
```

**서로소 집합을 활용한 사이클 판별**  
서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용한다.*(방향 그래프에서의 사이클 여부는 DFS로 판별 가능)*  
1. 각 간선을 하나씩 확인하여 두 노드의 루트 노드를 확인
    - 루트 노드가 서로 다르면 두 노드에 대해 합집합(Union) 연산 수행
    - 루트 노드가 서로 같다면 **사이클 발생**
2. 그래프의 모든 간선에 대해 1번 과정을 반복

> **최소 신장 트리**

신장 트리 : 그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프  
최소한의 비용으로 구성되는 신장 트리를 찾아야 할 때 (ex. N개의 도시를 모두 잇는 도로를 설치한다.)  
**크루스칼 알고리즘**  
대표적인 최소 신장 트리 알고리즘으로 그리디 알고리즘으로 분류됨.
1. 간선 데이터 비용에 따라 오름차순으로 정렬
2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
    - 사이클 O : 최소 신장 트리에 포함하지 않는다
    - 사이클 X : 최소 신장 트리에 포함한다.
3. 모든 간선에 대해 2번을 반복한다.
```text
크루스칼 알고리즘은 간선의 개수가 E개 일대, O(ElogE)의 시간 복잡도를 갖는다.
크루스칼 알고리즘에서 가장 많은 시간을 요구하는 곳은 간선을 정렬 수행하는 부분으로
표준 라이브러리를 이용해 E개의 데이터를 정렬하기 위한 시간 복잡도는 O(ElogE)이다.
```
> **위상정렬 : O(V+E)**

사이클이 없는 방향 그래프(DAG : Direct Acyclic Graph)의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것  
*(사이클이 있을 경우에는 모든 노드가 진입차수가 1이상이 되어 큐에 들어갈 수가 없음.)*  
모든 원소를 방문하기전에 큐가 빈다면 사이클이 존재하는 것.(사이클에 포함된 원소 중에서 어떠한 원소도 큐에 들어가지 못함)    
스택을 활용한 DFS를 이용해 수행 가능하다.  
ex. 선수 과목을 고려한 학습 순서 설정하기  
```text
진입 차수(Indegree) : 특정한 노드로 들어오는 간선의 개수
진출 차수(Outdegree) : 특정한 노드에서 나가는 간선의 개수
```
<큐를 이용한 위상 정렬 알고리즘의 동작 과정>
1. 진입 차수가 0인 모든 노드를 큐에 넣는다
2. 큐가 빌 때까지 다음의 과정을 반복한다.
   - 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거한다.
   - 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.


