# Algorithm with Python
파이썬을 이용한 알고리즘 공부 Repository입니다.
## basic
파이썬의 기본 문법
## greedy
그리디 알고리즘 : 현재 상황에서 지금 당장 좋은 것만 고르는 방법


**Q1. 거스름 돈 문제**

    가장 큰 화폐 단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유?  
    가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.  
    따라서 그리디 알고리즘 문제에서는 문제풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 줄 알아야한다.  


**Q2. 1이 될 때까지**  
N이 1이 될 때까지 다음의 과정중 하나를 반복적으로 선택해 수행한다. 단, 두번째 연산은 N이 k로 나누어 떨어질 때만 선택할 수 있다.
- N에서 1을 뺀다.
- N을 k로 나눈다.

예를 들어 N이 17, k가 4일때, 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다.  
따라서 전체 과정을 실행한 횟수는 3이 된다.

**Q3. 곱하기 혹은 더하기**  
각 자리가 숫자로만 이루어진 문자열 S. 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x'혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성해라.
단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다.

**Q4. 모험가 길드**  
한 마을의 모험가 N명을 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 위기 상황에서 대처할 능력이 떨어진다.  이에 길드장은 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있다.  
최대 몇개의 모험가 그룹을 만들 수 있는가?

## completeSearch (완전탐색)
2차원 공간에서의 방향 벡터가 활용됨
```python  
# 동, 북, 서, 남  
dx = [0, -1, 0, 1]  
dy = [1, 0, -1, 0]  
  
# 현재 위치  
x, y = 2, 2  
  
for i in range(4):  
    # 다음 위치  
    nx = x + dx[i]  
    ny = y + dy[i]  
    print(nx, ny)  
```  
**Q1. 상하좌우**  
A는 N X N 크기의 정사각형 공간 위에 있다. 이 공간은 1X1 크기의 정사각형으로 나누어져 있고, 가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는 (N, N) 이다. A는 상,하,좌,우로 이동할 수 있으며, 시작 좌표는 항상 (1,1)이다. 다음은 A가 이동할 계획이 적힌 계획서가 있다.  
계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여, L, R, U, D중 하나의 문자가 반복적으로 적혀 있고 그 의미는 다음과 같다
- L : 왼쪽으로 한 칸 이동
- R : 오른쪽으로 한 칸 이동
- U : 위로 한 칸 이동
- D : 아래로 한 칸 이동

이때 A가 N X N 크기 정사각형 공간을 벗어나는 움직임은 무시한다.

**Q2. 시간 문제(완전 탐색)**

    이 문제는 가능한 모든 시각의 경우를 모두 세서 풀 수 있는 문제이다.  
    단순히 시각을 1 씩 증가시키면서 3이 하나라도 포함되어 있는지 확인 
정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오.

**Q3. 왕실의 나이트**  
체스판 8X8 좌표 평면위에 나이트가 서있다. 나이트는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 나이트는 다음 2가지 경우로 이동할 수 있다.
1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기
2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기

나이트가 이동할 수 있는 경우의 수를 출력하시오.(행 위치는 1-8, 열 위치는 a-h로 표현한다.)

**Q4. 문자열 재정렬**  
알파벳 대문자와 숫자로만 구성된 문자열을 입력한다. 이때 모든 알파벳을 오름차순으로 정렬하여 출력한 뒤에 모든 숫자를 더한 값을 이어서 출력한다.

******
> **스택**

먼저 들어온 데이터가 나중에 나가는 형식 - **선입후출**  
파이썬에서는 별도의 라이브러리 사용없이 list의 append(), pop()함수를 사용해 스택을 활용할 수 있다.
```python  
# stack  
stack = []  
stack.append(5)  
stack.append(2)  
stack.append(3)  
stack.append(7)  
stack.pop()  
stack.append(1)  
stack.append(4)  
stack.pop()  
  
# 최상단 원소부터 출력  
print(stack[::-1])  
# 최하단 원소부터 출력  
print(stack)  
```  
>**큐**

먼저 들어온 데이터가 먼저 나가는 형식 - **선입선출**  
deque 라이브러리 사용 -> list로 기능적으로 사용가능하나 시간복잡도가 더 높음  
*단, deque의 경우는 오른쪽으로 데이터가 들어와 왼쪽으로 나간다고 생각해야함!*
```python  
# Queue  
from collections import deque  
# Queue구현을 위해 deque 라이브러리 사용  
queue = deque()  
queue.append(5)  
queue.append(2)  
queue.append(3)  
queue.append(7)  
queue.popleft()  
queue.append(1)  
queue.append(4)  
queue.popleft()  
  
# 들어온 순서대로 출력  
print(queue)  
# 역순으로 출력  
queue.reverse()  
print(queue)   
```  
>**재귀함수**

자기 자신을 다시 호출하는 함수 -> 무한히 출력할 경우 최대 재귀 깊이 초과 메시지 출력됨. 따라서 종료조건을 명시해야함
```python  
# 팩토리얼 구현  
# n! = 1 * 2 * 3 * 4 * ... * (n - 1) * n  
# 0!, 1! = 1  
  
# 반복적으로 구현한 n!  
def factorial_interative(n):  
    result = 1  
    # 1부터 n까지 차례대로 곱하기  
  for i in range(1, n+1):  
        result *= i  
    return result  
  
# 재귀적으로 구현한 n!  
def factorial_recursive(n):  
    if n <= 1: # n이 1이하인 경우 1 반환  
  return 1  
    # n! = n * (n-1)! 를 그대로 코드로 작성  
  return n * factorial_recursive(n - 1)  
  
print('반복 : ', factorial_interative(5))  
print('재귀 : ', factorial_recursive(5))  
  
# 최대공약수 계산 - 유클리드 호제법  
# 유클리드 호제법이란?  
# 두 자연수 A, B에 대하여 (A > B) A를 B로 나눈 나머지를 R이라고 한다.  
# 이때 A, B의 최대공약수는 B와 R의 최대공약수와 같다.  
def gcd(a, b):  
    if a % b == 0:  
        return b  
  else:  
        return gcd(b, a % b)  
  
print(gcd(192, 162))  
```  
****
## DFS, BFS
탐색? 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
>### DFS (깊이 우선 탐색)

스택 자료구조(혹은 재귀 함수)를 이용.
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복

**Q. 음료수 얼려먹기**  
N(세로길이) * M(가로길이) 크기의 얼음틀이 있다. 구멍이 뚫린 부분은 0, 칸막이가 존재하는 부분은 1로 표시. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주.  
이때 얼음 틀의 모양이 주어졌을 때 생성되는 아이스크림의 수는?  
00110  
00011  
11111  
00000  
의 경우에는 총 3개의 아이스크림이 생성됨  
*'연결된 얼음을 인접 노드라고 생각한다. 시작노드부터 연결된 모든 노드를 방문하고, 1인 경우에는 이동하지 못하기 때문에 방문한 것으로 간주. '*
1. 특정 지점의 상,하,좌,우를 살펴본 후, 주변 지점 중에서 값이 '0'이면서 아직 방문하지 않은 지점이 있으면 해당 지점 방문
2. 방문한 지점에서 다시 상,하,좌,우를 살펴보면서 방문을 진행하는 과정을 반복하면, 연결된 모든 지점을 방문
3. 모든 노드에 대해 1,2번을 반복, 방문하지 않은 지점의 수를 카운트

>### BFS (너비 우선 탐색)

가까운 노드부터 우선적으로 탐색하며, 큐 자료구조를 이용  
다리 선의 비용이 모두 같다는 가정하에 최단거리 문제에서도 사용됨.
1. 탐색 시작 노드를 큐에 삽입하고 방문처리
2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 모든 노드를 큐에 삽입하고 방문 처리
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복


**Q. 미로탈출**  
N * M 크기의 미로가 있다. A의 위치는 (1, 1)이며 미로의 출구는 (N, M)이고, 한 번에 한 칸씩 이동할 수 있다.  
이때 갈 수 없는 부분은 0으로, 갈 수 있는 부분은 1로 표시한다. 탈출하기 위한 최소 칸의 개수는?  
단, 칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함해서 계산한다.  
101010  
111111  
000001  
111111  
111111   
인 경우 정답은 10이다.

***'BFS는 연결 값이 동일한 경우 최단 거리를 찾는데 좋은 방법이다. 시작지점에서 가까운 노드부터 차례대로 그래프의 모든 노드를 탐색한다.'***
1. (1, 1)의 위치에서 시작
2. (1, 1)좌표에서 상,하,좌,우로 탐색을 진행하면 바로 옆 노드인 (1, 2) 위치의 노드를 방문하게 되고 새롭게 방문하는 (1, 2) 노드의 값을 2로 바꾼다.
3. BFS를 계속 수행하면 결과적으로 다음과 같이 최단 경로의 값들이 1씩 증가하는 형태로 변경